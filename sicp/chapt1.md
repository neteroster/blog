# 第一章：构建过程的抽象

* 计算过程的定义：计算过程是**居于计算机中的抽象实体**，随着计算过程的演化，它可以操作另外一些抽象实体，例如数据。程序用于引导计算过程，就像召唤魔法的咒语。
* Lisp 最初是一种形式化方法，用于处理作为计算模型的递归方程。
* Lisp 的名字是 LISt Processing 的缩写，它旨在为解决编程问题（如代数表达式的符号微分和积分）提供符号操作的能力。为了实现这个目标，Lisp 引入了新的数据对象，称为“原子”和“列表”，这是它与当时所有其他语言最引人注目的不同之处。
* 强大的编程语言是我们表达想法的关键。研究编程语言时，特别注意编程语言提供的组合不同简单想法为复杂想法的方式。一个强大的语言通常提供三种这样的方式：(1) 原始表达式 (primitive expressions)，表示语言关心的最简单实体；(2) 组合方式 (means of combination)，使得可以由简单元素构造复合元素；(3) 抽象方式 (means of abstraction)，使得复合元素可以作为单元 (units) 被命名和操作。
* 十进制数字（例如 `486`）是一个**原始表达式**。
* 对 Scheme 解释器输入一个表达式 (expression)，解释器返回**对这个表达式的求值** (evaluating)。
* 例如 `+` 和 `*` 是**表达式**，用于表示**原始过程 (primitive procedure)**。
* 表示数字的表达式可以与表示原始过程的表达式组合起来，形成一个复合表达式，表示对数字应用过程。（`(+ 137 349)`）

例如 `(+ 137 349)` 也是一种**表达式**，通过在括号内限定 **一个表达式的列表 (a list of expressions)** 来表达过程应用。这种表达式称为 **组合 (combinations)**。
列表中最左边的元素被称为操作符 (**operator**)，而其他元素被称为操作数 (**operands**)。通过将操作符所指定的过程应用到作为参数的操作数，我们可以得到组合的值。

把操作符放在左侧的约定称为**前缀表示法 (prefix notations)**。有一些优点，例如：可以适应接收任意数量参数的**过程**，例如 `(+ 1 2 3 4)`。另一个优点是容易嵌套。

* 一个名字可以标识一个变量 (variable)，变量的值 (value) 是可计算对象。
* `define` 是最简单的抽象方法，他让我们能用简单的名字指涉复合操作的结果。
* 为了维护名称-对象 (name-object) 关系，编译器需要某种记忆 (memory) 来跟踪名称-对象对的关系。这种记忆叫做环境 (environment)。
* 递归求值的基情形：(1) 数字的值是他们的名字本身；(2) 原始过程的值是对应的机器指令序列；(3) 其余名字的值是环境中与之对应的对象。
* 上面基情形中，(2) 可以视作 (3) 的特例。从此可以窥见环境在求值中的的重要性（如果没有环境，表达式 `(+ x 1)` 就无从谈起）。
* 环境为求值提供上下文，这种想法将起到重要作用。
* `(define x 3)` 不是一个组合 (combination)，因为对他求值不会将 `define` 应用到 `x` 和 `3` 上，而是将 `x` 和 `3` 在环境中关联起来。然而，它~仍然是一个表达式~（[存疑](https://stackoverflow.com/questions/66463405/what-does-scheme-define-expression-return)）。
* 像 `(define x 3)` 这样的在**通用的求值规则 (general evaluation rule)** 中的例外称为**特别形式 (special forms)**。目前 `define` 是遇到的第一个特别形式，后序还有更多。
* 每一个特别形式都有自己的求值规则。
* **不同种类的表达式（和它们对应的求值规则一起）** 构成了编程语言的**语法 (syntax)**。
* 对复合过程构成的组合求值仍然是对每一个子表达式求值，然后将操作符的过程**应用**到操作数上。对于原始过程，这种应用内建于解释器。对于复合过程，“应用”的值遵循规则：把复合过程的主体 (body) 中的形参替换为实参，然后对替换后的主体 (body) 求值。（因为主体仍是表达式或表达式的序列，所以可以求值。）上述过程称为**过程应用的 替换模型 (substitution model)**。**它可以看作是确定“过程应用”的含义的模型。**
* 注意替换模型的求值顺序：不仅可以先求值，再替换，也可以先替换，直到只有原始过程时再求值。即：在获得一个全为原始操作符的表达式之前，不执行任何求值，仅仅替换。先求值再替换称为 **applicative-order evaluation**，是实际情况下更常用的。先替换，最后求值称为 **normal-order evaluation**，会有额外的重复计算。两种方式在大部分情况下求得相同的值，不过也会有时有差异。可以证明，在可以用替换模型建模的过程应用下，如果一个表达式具有合法的 (legitimate) 值，则两者产生相同的求值结果。
* 当描述不能由替换模型建模的过程时，通常 applicative-order evaluation 会比 normal-order evaluation 更简单。不过，normal-order evaluation 也会有珍贵的性质，这在后面章节描述。
* cond 表达式是一个特别形式 (special form)，cond 表达式中，`(<p> <e>)` 对叫做 **clauses**。
* cond 求值从上往下（或者说从左往右）遇到第一个谓词 (predicate) 为真的返回对应的 **consequent expression**。
